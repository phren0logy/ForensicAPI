"""
Comprehensive tests for the /extract endpoint.

Tests PDF extraction functionality including:
- Basic extraction with sample PDF
- Element ID generation
- Batch processing parameters
- Error handling
"""

import io
import json
from pathlib import Path
from fastapi.testclient import TestClient
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter

from main import app

client = TestClient(app)


def create_test_pdf(num_pages: int = 2) -> bytes:
    """Create a simple test PDF with specified number of pages."""
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    
    for page_num in range(1, num_pages + 1):
        c.drawString(100, 700, f"Test PDF - Page {page_num}")
        c.drawString(100, 650, f"This is a test document for extraction.")
        c.drawString(100, 600, f"It contains some sample text on page {page_num}.")
        c.showPage()
    
    c.save()
    buffer.seek(0)
    return buffer.read()


def test_extract_basic():
    """Test basic PDF extraction functionality."""
    # Create a simple test PDF
    pdf_content = create_test_pdf(num_pages=2)
    
    files = {"file": ("test.pdf", pdf_content, "application/pdf")}
    resp = client.post("/extract", files=files)
    
    assert resp.status_code == 200
    result = resp.json()
    
    # Verify response structure
    assert "markdown_content" in result
    assert "analysis_result" in result
    
    # Check that content was extracted
    assert len(result["markdown_content"]) > 0
    assert "Test PDF" in result["markdown_content"]
    
    # Verify Azure DI structure
    analysis = result["analysis_result"]
    assert "content" in analysis
    assert "paragraphs" in analysis
    

def test_extract_with_element_ids():
    """Test that element IDs are generated by default."""
    pdf_content = create_test_pdf(num_pages=1)
    
    files = {"file": ("test.pdf", pdf_content, "application/pdf")}
    resp = client.post("/extract", files=files)
    
    assert resp.status_code == 200
    result = resp.json()
    
    # Check that paragraphs have IDs
    paragraphs = result["analysis_result"].get("paragraphs", [])
    if paragraphs:
        assert all("_id" in p for p in paragraphs)
        # Verify ID format
        first_id = paragraphs[0]["_id"]
        assert first_id.startswith("para_")
        assert len(first_id.split("_")) == 4  # type_page_index_hash
    

def test_extract_without_element_ids():
    """Test extraction with element IDs disabled."""
    pdf_content = create_test_pdf(num_pages=1)
    
    files = {"file": ("test.pdf", pdf_content, "application/pdf")}
    data = {"include_element_ids": "false"}
    resp = client.post("/extract", files=files, data=data)
    
    assert resp.status_code == 200
    result = resp.json()
    
    # Check that paragraphs don't have IDs
    paragraphs = result["analysis_result"].get("paragraphs", [])
    if paragraphs:
        assert all("_id" not in p for p in paragraphs)


def test_extract_return_both():
    """Test extraction returning both ID and non-ID versions."""
    pdf_content = create_test_pdf(num_pages=1)
    
    files = {"file": ("test.pdf", pdf_content, "application/pdf")}
    data = {"return_both": "true"}
    resp = client.post("/extract", files=files, data=data)
    
    assert resp.status_code == 200
    result = resp.json()
    
    # Should have both versions
    assert "analysis_result" in result
    assert "analysis_result_original" in result
    
    # ID version should have IDs
    paragraphs_with_ids = result["analysis_result"].get("paragraphs", [])
    if paragraphs_with_ids:
        assert all("_id" in p for p in paragraphs_with_ids)
    
    # Original version should not have IDs
    paragraphs_original = result["analysis_result_original"].get("paragraphs", [])
    if paragraphs_original:
        assert all("_id" not in p for p in paragraphs_original)


def test_extract_custom_batch_size():
    """Test extraction with custom batch size."""
    pdf_content = create_test_pdf(num_pages=3)
    
    files = {"file": ("test.pdf", pdf_content, "application/pdf")}
    data = {"batch_size": "1"}  # Process one page at a time
    resp = client.post("/extract", files=files, data=data)
    
    assert resp.status_code == 200
    result = resp.json()
    assert "analysis_result" in result


def test_extract_invalid_file_type():
    """Test extraction with non-PDF file."""
    files = {"file": ("test.txt", b"This is not a PDF", "text/plain")}
    resp = client.post("/extract", files=files)
    
    # Should return an error (actual status depends on implementation)
    assert resp.status_code in [400, 422, 500]


def test_extract_empty_pdf():
    """Test extraction with empty PDF."""
    # Create an empty PDF
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    c.save()
    buffer.seek(0)
    
    files = {"file": ("empty.pdf", buffer.read(), "application/pdf")}
    resp = client.post("/extract", files=files)
    
    # Should still succeed but with minimal content
    assert resp.status_code == 200
    result = resp.json()
    assert "analysis_result" in result


def test_extract_real_sample_pdf():
    """Test extraction with the real sample PDF if it exists."""
    sample_pdf_path = Path(__file__).parent / "sample_pdfs" / "05dracula.pdf"
    
    if sample_pdf_path.exists():
        with open(sample_pdf_path, "rb") as f:
            pdf_content = f.read()
        
        # Only process first 5 pages to keep test fast
        files = {"file": ("dracula_sample.pdf", pdf_content, "application/pdf")}
        data = {"batch_size": "5"}
        resp = client.post("/extract", files=files, data=data)
        
        assert resp.status_code == 200
        result = resp.json()
        
        # Should have substantial content
        assert len(result["markdown_content"]) > 1000
        assert "analysis_result" in result
        
        # Check for proper extraction
        assert "Dracula" in result["markdown_content"] or "DRACULA" in result["markdown_content"]